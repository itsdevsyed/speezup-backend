
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `StoreCategory` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model StoreCategory
 * 
 */
export type StoreCategoryModel = runtime.Types.Result.DefaultSelection<Prisma.$StoreCategoryPayload>

export type AggregateStoreCategory = {
  _count: StoreCategoryCountAggregateOutputType | null
  _avg: StoreCategoryAvgAggregateOutputType | null
  _sum: StoreCategorySumAggregateOutputType | null
  _min: StoreCategoryMinAggregateOutputType | null
  _max: StoreCategoryMaxAggregateOutputType | null
}

export type StoreCategoryAvgAggregateOutputType = {
  id: number | null
}

export type StoreCategorySumAggregateOutputType = {
  id: number | null
}

export type StoreCategoryMinAggregateOutputType = {
  id: number | null
  name: string | null
}

export type StoreCategoryMaxAggregateOutputType = {
  id: number | null
  name: string | null
}

export type StoreCategoryCountAggregateOutputType = {
  id: number
  name: number
  _all: number
}


export type StoreCategoryAvgAggregateInputType = {
  id?: true
}

export type StoreCategorySumAggregateInputType = {
  id?: true
}

export type StoreCategoryMinAggregateInputType = {
  id?: true
  name?: true
}

export type StoreCategoryMaxAggregateInputType = {
  id?: true
  name?: true
}

export type StoreCategoryCountAggregateInputType = {
  id?: true
  name?: true
  _all?: true
}

export type StoreCategoryAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which StoreCategory to aggregate.
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StoreCategories to fetch.
   */
  orderBy?: Prisma.StoreCategoryOrderByWithRelationInput | Prisma.StoreCategoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.StoreCategoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StoreCategories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StoreCategories.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned StoreCategories
  **/
  _count?: true | StoreCategoryCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: StoreCategoryAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: StoreCategorySumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: StoreCategoryMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: StoreCategoryMaxAggregateInputType
}

export type GetStoreCategoryAggregateType<T extends StoreCategoryAggregateArgs> = {
      [P in keyof T & keyof AggregateStoreCategory]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateStoreCategory[P]>
    : Prisma.GetScalarType<T[P], AggregateStoreCategory[P]>
}




export type StoreCategoryGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.StoreCategoryWhereInput
  orderBy?: Prisma.StoreCategoryOrderByWithAggregationInput | Prisma.StoreCategoryOrderByWithAggregationInput[]
  by: Prisma.StoreCategoryScalarFieldEnum[] | Prisma.StoreCategoryScalarFieldEnum
  having?: Prisma.StoreCategoryScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: StoreCategoryCountAggregateInputType | true
  _avg?: StoreCategoryAvgAggregateInputType
  _sum?: StoreCategorySumAggregateInputType
  _min?: StoreCategoryMinAggregateInputType
  _max?: StoreCategoryMaxAggregateInputType
}

export type StoreCategoryGroupByOutputType = {
  id: number
  name: string
  _count: StoreCategoryCountAggregateOutputType | null
  _avg: StoreCategoryAvgAggregateOutputType | null
  _sum: StoreCategorySumAggregateOutputType | null
  _min: StoreCategoryMinAggregateOutputType | null
  _max: StoreCategoryMaxAggregateOutputType | null
}

type GetStoreCategoryGroupByPayload<T extends StoreCategoryGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<StoreCategoryGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof StoreCategoryGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], StoreCategoryGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], StoreCategoryGroupByOutputType[P]>
      }
    >
  >



export type StoreCategoryWhereInput = {
  AND?: Prisma.StoreCategoryWhereInput | Prisma.StoreCategoryWhereInput[]
  OR?: Prisma.StoreCategoryWhereInput[]
  NOT?: Prisma.StoreCategoryWhereInput | Prisma.StoreCategoryWhereInput[]
  id?: Prisma.IntFilter<"StoreCategory"> | number
  name?: Prisma.StringFilter<"StoreCategory"> | string
  stores?: Prisma.StoreListRelationFilter
}

export type StoreCategoryOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  stores?: Prisma.StoreOrderByRelationAggregateInput
}

export type StoreCategoryWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  name?: string
  AND?: Prisma.StoreCategoryWhereInput | Prisma.StoreCategoryWhereInput[]
  OR?: Prisma.StoreCategoryWhereInput[]
  NOT?: Prisma.StoreCategoryWhereInput | Prisma.StoreCategoryWhereInput[]
  stores?: Prisma.StoreListRelationFilter
}, "id" | "name">

export type StoreCategoryOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  _count?: Prisma.StoreCategoryCountOrderByAggregateInput
  _avg?: Prisma.StoreCategoryAvgOrderByAggregateInput
  _max?: Prisma.StoreCategoryMaxOrderByAggregateInput
  _min?: Prisma.StoreCategoryMinOrderByAggregateInput
  _sum?: Prisma.StoreCategorySumOrderByAggregateInput
}

export type StoreCategoryScalarWhereWithAggregatesInput = {
  AND?: Prisma.StoreCategoryScalarWhereWithAggregatesInput | Prisma.StoreCategoryScalarWhereWithAggregatesInput[]
  OR?: Prisma.StoreCategoryScalarWhereWithAggregatesInput[]
  NOT?: Prisma.StoreCategoryScalarWhereWithAggregatesInput | Prisma.StoreCategoryScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"StoreCategory"> | number
  name?: Prisma.StringWithAggregatesFilter<"StoreCategory"> | string
}

export type StoreCategoryCreateInput = {
  name: string
  stores?: Prisma.StoreCreateNestedManyWithoutStoreCategoriesInput
}

export type StoreCategoryUncheckedCreateInput = {
  id?: number
  name: string
  stores?: Prisma.StoreUncheckedCreateNestedManyWithoutStoreCategoriesInput
}

export type StoreCategoryUpdateInput = {
  name?: Prisma.StringFieldUpdateOperationsInput | string
  stores?: Prisma.StoreUpdateManyWithoutStoreCategoriesNestedInput
}

export type StoreCategoryUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
  stores?: Prisma.StoreUncheckedUpdateManyWithoutStoreCategoriesNestedInput
}

export type StoreCategoryCreateManyInput = {
  id?: number
  name: string
}

export type StoreCategoryUpdateManyMutationInput = {
  name?: Prisma.StringFieldUpdateOperationsInput | string
}

export type StoreCategoryUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
}

export type StoreCategoryListRelationFilter = {
  every?: Prisma.StoreCategoryWhereInput
  some?: Prisma.StoreCategoryWhereInput
  none?: Prisma.StoreCategoryWhereInput
}

export type StoreCategoryOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type StoreCategoryCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
}

export type StoreCategoryAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
}

export type StoreCategoryMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
}

export type StoreCategoryMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
}

export type StoreCategorySumOrderByAggregateInput = {
  id?: Prisma.SortOrder
}

export type StoreCategoryCreateNestedManyWithoutStoresInput = {
  create?: Prisma.XOR<Prisma.StoreCategoryCreateWithoutStoresInput, Prisma.StoreCategoryUncheckedCreateWithoutStoresInput> | Prisma.StoreCategoryCreateWithoutStoresInput[] | Prisma.StoreCategoryUncheckedCreateWithoutStoresInput[]
  connectOrCreate?: Prisma.StoreCategoryCreateOrConnectWithoutStoresInput | Prisma.StoreCategoryCreateOrConnectWithoutStoresInput[]
  connect?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
}

export type StoreCategoryUncheckedCreateNestedManyWithoutStoresInput = {
  create?: Prisma.XOR<Prisma.StoreCategoryCreateWithoutStoresInput, Prisma.StoreCategoryUncheckedCreateWithoutStoresInput> | Prisma.StoreCategoryCreateWithoutStoresInput[] | Prisma.StoreCategoryUncheckedCreateWithoutStoresInput[]
  connectOrCreate?: Prisma.StoreCategoryCreateOrConnectWithoutStoresInput | Prisma.StoreCategoryCreateOrConnectWithoutStoresInput[]
  connect?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
}

export type StoreCategoryUpdateManyWithoutStoresNestedInput = {
  create?: Prisma.XOR<Prisma.StoreCategoryCreateWithoutStoresInput, Prisma.StoreCategoryUncheckedCreateWithoutStoresInput> | Prisma.StoreCategoryCreateWithoutStoresInput[] | Prisma.StoreCategoryUncheckedCreateWithoutStoresInput[]
  connectOrCreate?: Prisma.StoreCategoryCreateOrConnectWithoutStoresInput | Prisma.StoreCategoryCreateOrConnectWithoutStoresInput[]
  upsert?: Prisma.StoreCategoryUpsertWithWhereUniqueWithoutStoresInput | Prisma.StoreCategoryUpsertWithWhereUniqueWithoutStoresInput[]
  set?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  disconnect?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  delete?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  connect?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  update?: Prisma.StoreCategoryUpdateWithWhereUniqueWithoutStoresInput | Prisma.StoreCategoryUpdateWithWhereUniqueWithoutStoresInput[]
  updateMany?: Prisma.StoreCategoryUpdateManyWithWhereWithoutStoresInput | Prisma.StoreCategoryUpdateManyWithWhereWithoutStoresInput[]
  deleteMany?: Prisma.StoreCategoryScalarWhereInput | Prisma.StoreCategoryScalarWhereInput[]
}

export type StoreCategoryUncheckedUpdateManyWithoutStoresNestedInput = {
  create?: Prisma.XOR<Prisma.StoreCategoryCreateWithoutStoresInput, Prisma.StoreCategoryUncheckedCreateWithoutStoresInput> | Prisma.StoreCategoryCreateWithoutStoresInput[] | Prisma.StoreCategoryUncheckedCreateWithoutStoresInput[]
  connectOrCreate?: Prisma.StoreCategoryCreateOrConnectWithoutStoresInput | Prisma.StoreCategoryCreateOrConnectWithoutStoresInput[]
  upsert?: Prisma.StoreCategoryUpsertWithWhereUniqueWithoutStoresInput | Prisma.StoreCategoryUpsertWithWhereUniqueWithoutStoresInput[]
  set?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  disconnect?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  delete?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  connect?: Prisma.StoreCategoryWhereUniqueInput | Prisma.StoreCategoryWhereUniqueInput[]
  update?: Prisma.StoreCategoryUpdateWithWhereUniqueWithoutStoresInput | Prisma.StoreCategoryUpdateWithWhereUniqueWithoutStoresInput[]
  updateMany?: Prisma.StoreCategoryUpdateManyWithWhereWithoutStoresInput | Prisma.StoreCategoryUpdateManyWithWhereWithoutStoresInput[]
  deleteMany?: Prisma.StoreCategoryScalarWhereInput | Prisma.StoreCategoryScalarWhereInput[]
}

export type StoreCategoryCreateWithoutStoresInput = {
  name: string
}

export type StoreCategoryUncheckedCreateWithoutStoresInput = {
  id?: number
  name: string
}

export type StoreCategoryCreateOrConnectWithoutStoresInput = {
  where: Prisma.StoreCategoryWhereUniqueInput
  create: Prisma.XOR<Prisma.StoreCategoryCreateWithoutStoresInput, Prisma.StoreCategoryUncheckedCreateWithoutStoresInput>
}

export type StoreCategoryUpsertWithWhereUniqueWithoutStoresInput = {
  where: Prisma.StoreCategoryWhereUniqueInput
  update: Prisma.XOR<Prisma.StoreCategoryUpdateWithoutStoresInput, Prisma.StoreCategoryUncheckedUpdateWithoutStoresInput>
  create: Prisma.XOR<Prisma.StoreCategoryCreateWithoutStoresInput, Prisma.StoreCategoryUncheckedCreateWithoutStoresInput>
}

export type StoreCategoryUpdateWithWhereUniqueWithoutStoresInput = {
  where: Prisma.StoreCategoryWhereUniqueInput
  data: Prisma.XOR<Prisma.StoreCategoryUpdateWithoutStoresInput, Prisma.StoreCategoryUncheckedUpdateWithoutStoresInput>
}

export type StoreCategoryUpdateManyWithWhereWithoutStoresInput = {
  where: Prisma.StoreCategoryScalarWhereInput
  data: Prisma.XOR<Prisma.StoreCategoryUpdateManyMutationInput, Prisma.StoreCategoryUncheckedUpdateManyWithoutStoresInput>
}

export type StoreCategoryScalarWhereInput = {
  AND?: Prisma.StoreCategoryScalarWhereInput | Prisma.StoreCategoryScalarWhereInput[]
  OR?: Prisma.StoreCategoryScalarWhereInput[]
  NOT?: Prisma.StoreCategoryScalarWhereInput | Prisma.StoreCategoryScalarWhereInput[]
  id?: Prisma.IntFilter<"StoreCategory"> | number
  name?: Prisma.StringFilter<"StoreCategory"> | string
}

export type StoreCategoryUpdateWithoutStoresInput = {
  name?: Prisma.StringFieldUpdateOperationsInput | string
}

export type StoreCategoryUncheckedUpdateWithoutStoresInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
}

export type StoreCategoryUncheckedUpdateManyWithoutStoresInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
}


/**
 * Count Type StoreCategoryCountOutputType
 */

export type StoreCategoryCountOutputType = {
  stores: number
}

export type StoreCategoryCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  stores?: boolean | StoreCategoryCountOutputTypeCountStoresArgs
}

/**
 * StoreCategoryCountOutputType without action
 */
export type StoreCategoryCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategoryCountOutputType
   */
  select?: Prisma.StoreCategoryCountOutputTypeSelect<ExtArgs> | null
}

/**
 * StoreCategoryCountOutputType without action
 */
export type StoreCategoryCountOutputTypeCountStoresArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.StoreWhereInput
}


export type StoreCategorySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  name?: boolean
  stores?: boolean | Prisma.StoreCategory$storesArgs<ExtArgs>
  _count?: boolean | Prisma.StoreCategoryCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["storeCategory"]>

export type StoreCategorySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  name?: boolean
}, ExtArgs["result"]["storeCategory"]>

export type StoreCategorySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  name?: boolean
}, ExtArgs["result"]["storeCategory"]>

export type StoreCategorySelectScalar = {
  id?: boolean
  name?: boolean
}

export type StoreCategoryOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "name", ExtArgs["result"]["storeCategory"]>
export type StoreCategoryInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  stores?: boolean | Prisma.StoreCategory$storesArgs<ExtArgs>
  _count?: boolean | Prisma.StoreCategoryCountOutputTypeDefaultArgs<ExtArgs>
}
export type StoreCategoryIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type StoreCategoryIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $StoreCategoryPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "StoreCategory"
  objects: {
    stores: Prisma.$StorePayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    name: string
  }, ExtArgs["result"]["storeCategory"]>
  composites: {}
}

export type StoreCategoryGetPayload<S extends boolean | null | undefined | StoreCategoryDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload, S>

export type StoreCategoryCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<StoreCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: StoreCategoryCountAggregateInputType | true
  }

export interface StoreCategoryDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreCategory'], meta: { name: 'StoreCategory' } }
  /**
   * Find zero or one StoreCategory that matches the filter.
   * @param {StoreCategoryFindUniqueArgs} args - Arguments to find a StoreCategory
   * @example
   * // Get one StoreCategory
   * const storeCategory = await prisma.storeCategory.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends StoreCategoryFindUniqueArgs>(args: Prisma.SelectSubset<T, StoreCategoryFindUniqueArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one StoreCategory that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {StoreCategoryFindUniqueOrThrowArgs} args - Arguments to find a StoreCategory
   * @example
   * // Get one StoreCategory
   * const storeCategory = await prisma.storeCategory.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends StoreCategoryFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, StoreCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first StoreCategory that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryFindFirstArgs} args - Arguments to find a StoreCategory
   * @example
   * // Get one StoreCategory
   * const storeCategory = await prisma.storeCategory.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends StoreCategoryFindFirstArgs>(args?: Prisma.SelectSubset<T, StoreCategoryFindFirstArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first StoreCategory that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryFindFirstOrThrowArgs} args - Arguments to find a StoreCategory
   * @example
   * // Get one StoreCategory
   * const storeCategory = await prisma.storeCategory.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends StoreCategoryFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, StoreCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more StoreCategories that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all StoreCategories
   * const storeCategories = await prisma.storeCategory.findMany()
   * 
   * // Get first 10 StoreCategories
   * const storeCategories = await prisma.storeCategory.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const storeCategoryWithIdOnly = await prisma.storeCategory.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends StoreCategoryFindManyArgs>(args?: Prisma.SelectSubset<T, StoreCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a StoreCategory.
   * @param {StoreCategoryCreateArgs} args - Arguments to create a StoreCategory.
   * @example
   * // Create one StoreCategory
   * const StoreCategory = await prisma.storeCategory.create({
   *   data: {
   *     // ... data to create a StoreCategory
   *   }
   * })
   * 
   */
  create<T extends StoreCategoryCreateArgs>(args: Prisma.SelectSubset<T, StoreCategoryCreateArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many StoreCategories.
   * @param {StoreCategoryCreateManyArgs} args - Arguments to create many StoreCategories.
   * @example
   * // Create many StoreCategories
   * const storeCategory = await prisma.storeCategory.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends StoreCategoryCreateManyArgs>(args?: Prisma.SelectSubset<T, StoreCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many StoreCategories and returns the data saved in the database.
   * @param {StoreCategoryCreateManyAndReturnArgs} args - Arguments to create many StoreCategories.
   * @example
   * // Create many StoreCategories
   * const storeCategory = await prisma.storeCategory.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many StoreCategories and only return the `id`
   * const storeCategoryWithIdOnly = await prisma.storeCategory.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends StoreCategoryCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, StoreCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a StoreCategory.
   * @param {StoreCategoryDeleteArgs} args - Arguments to delete one StoreCategory.
   * @example
   * // Delete one StoreCategory
   * const StoreCategory = await prisma.storeCategory.delete({
   *   where: {
   *     // ... filter to delete one StoreCategory
   *   }
   * })
   * 
   */
  delete<T extends StoreCategoryDeleteArgs>(args: Prisma.SelectSubset<T, StoreCategoryDeleteArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one StoreCategory.
   * @param {StoreCategoryUpdateArgs} args - Arguments to update one StoreCategory.
   * @example
   * // Update one StoreCategory
   * const storeCategory = await prisma.storeCategory.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends StoreCategoryUpdateArgs>(args: Prisma.SelectSubset<T, StoreCategoryUpdateArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more StoreCategories.
   * @param {StoreCategoryDeleteManyArgs} args - Arguments to filter StoreCategories to delete.
   * @example
   * // Delete a few StoreCategories
   * const { count } = await prisma.storeCategory.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends StoreCategoryDeleteManyArgs>(args?: Prisma.SelectSubset<T, StoreCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more StoreCategories.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many StoreCategories
   * const storeCategory = await prisma.storeCategory.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends StoreCategoryUpdateManyArgs>(args: Prisma.SelectSubset<T, StoreCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more StoreCategories and returns the data updated in the database.
   * @param {StoreCategoryUpdateManyAndReturnArgs} args - Arguments to update many StoreCategories.
   * @example
   * // Update many StoreCategories
   * const storeCategory = await prisma.storeCategory.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more StoreCategories and only return the `id`
   * const storeCategoryWithIdOnly = await prisma.storeCategory.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends StoreCategoryUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, StoreCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one StoreCategory.
   * @param {StoreCategoryUpsertArgs} args - Arguments to update or create a StoreCategory.
   * @example
   * // Update or create a StoreCategory
   * const storeCategory = await prisma.storeCategory.upsert({
   *   create: {
   *     // ... data to create a StoreCategory
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the StoreCategory we want to update
   *   }
   * })
   */
  upsert<T extends StoreCategoryUpsertArgs>(args: Prisma.SelectSubset<T, StoreCategoryUpsertArgs<ExtArgs>>): Prisma.Prisma__StoreCategoryClient<runtime.Types.Result.GetResult<Prisma.$StoreCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of StoreCategories.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryCountArgs} args - Arguments to filter StoreCategories to count.
   * @example
   * // Count the number of StoreCategories
   * const count = await prisma.storeCategory.count({
   *   where: {
   *     // ... the filter for the StoreCategories we want to count
   *   }
   * })
  **/
  count<T extends StoreCategoryCountArgs>(
    args?: Prisma.Subset<T, StoreCategoryCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], StoreCategoryCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a StoreCategory.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends StoreCategoryAggregateArgs>(args: Prisma.Subset<T, StoreCategoryAggregateArgs>): Prisma.PrismaPromise<GetStoreCategoryAggregateType<T>>

  /**
   * Group by StoreCategory.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StoreCategoryGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends StoreCategoryGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: StoreCategoryGroupByArgs['orderBy'] }
      : { orderBy?: StoreCategoryGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, StoreCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the StoreCategory model
 */
readonly fields: StoreCategoryFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for StoreCategory.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__StoreCategoryClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  stores<T extends Prisma.StoreCategory$storesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.StoreCategory$storesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the StoreCategory model
 */
export interface StoreCategoryFieldRefs {
  readonly id: Prisma.FieldRef<"StoreCategory", 'Int'>
  readonly name: Prisma.FieldRef<"StoreCategory", 'String'>
}
    

// Custom InputTypes
/**
 * StoreCategory findUnique
 */
export type StoreCategoryFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * Filter, which StoreCategory to fetch.
   */
  where: Prisma.StoreCategoryWhereUniqueInput
}

/**
 * StoreCategory findUniqueOrThrow
 */
export type StoreCategoryFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * Filter, which StoreCategory to fetch.
   */
  where: Prisma.StoreCategoryWhereUniqueInput
}

/**
 * StoreCategory findFirst
 */
export type StoreCategoryFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * Filter, which StoreCategory to fetch.
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StoreCategories to fetch.
   */
  orderBy?: Prisma.StoreCategoryOrderByWithRelationInput | Prisma.StoreCategoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for StoreCategories.
   */
  cursor?: Prisma.StoreCategoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StoreCategories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StoreCategories.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of StoreCategories.
   */
  distinct?: Prisma.StoreCategoryScalarFieldEnum | Prisma.StoreCategoryScalarFieldEnum[]
}

/**
 * StoreCategory findFirstOrThrow
 */
export type StoreCategoryFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * Filter, which StoreCategory to fetch.
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StoreCategories to fetch.
   */
  orderBy?: Prisma.StoreCategoryOrderByWithRelationInput | Prisma.StoreCategoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for StoreCategories.
   */
  cursor?: Prisma.StoreCategoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StoreCategories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StoreCategories.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of StoreCategories.
   */
  distinct?: Prisma.StoreCategoryScalarFieldEnum | Prisma.StoreCategoryScalarFieldEnum[]
}

/**
 * StoreCategory findMany
 */
export type StoreCategoryFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * Filter, which StoreCategories to fetch.
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StoreCategories to fetch.
   */
  orderBy?: Prisma.StoreCategoryOrderByWithRelationInput | Prisma.StoreCategoryOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing StoreCategories.
   */
  cursor?: Prisma.StoreCategoryWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StoreCategories from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StoreCategories.
   */
  skip?: number
  distinct?: Prisma.StoreCategoryScalarFieldEnum | Prisma.StoreCategoryScalarFieldEnum[]
}

/**
 * StoreCategory create
 */
export type StoreCategoryCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * The data needed to create a StoreCategory.
   */
  data: Prisma.XOR<Prisma.StoreCategoryCreateInput, Prisma.StoreCategoryUncheckedCreateInput>
}

/**
 * StoreCategory createMany
 */
export type StoreCategoryCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many StoreCategories.
   */
  data: Prisma.StoreCategoryCreateManyInput | Prisma.StoreCategoryCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * StoreCategory createManyAndReturn
 */
export type StoreCategoryCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * The data used to create many StoreCategories.
   */
  data: Prisma.StoreCategoryCreateManyInput | Prisma.StoreCategoryCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * StoreCategory update
 */
export type StoreCategoryUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * The data needed to update a StoreCategory.
   */
  data: Prisma.XOR<Prisma.StoreCategoryUpdateInput, Prisma.StoreCategoryUncheckedUpdateInput>
  /**
   * Choose, which StoreCategory to update.
   */
  where: Prisma.StoreCategoryWhereUniqueInput
}

/**
 * StoreCategory updateMany
 */
export type StoreCategoryUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update StoreCategories.
   */
  data: Prisma.XOR<Prisma.StoreCategoryUpdateManyMutationInput, Prisma.StoreCategoryUncheckedUpdateManyInput>
  /**
   * Filter which StoreCategories to update
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * Limit how many StoreCategories to update.
   */
  limit?: number
}

/**
 * StoreCategory updateManyAndReturn
 */
export type StoreCategoryUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * The data used to update StoreCategories.
   */
  data: Prisma.XOR<Prisma.StoreCategoryUpdateManyMutationInput, Prisma.StoreCategoryUncheckedUpdateManyInput>
  /**
   * Filter which StoreCategories to update
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * Limit how many StoreCategories to update.
   */
  limit?: number
}

/**
 * StoreCategory upsert
 */
export type StoreCategoryUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * The filter to search for the StoreCategory to update in case it exists.
   */
  where: Prisma.StoreCategoryWhereUniqueInput
  /**
   * In case the StoreCategory found by the `where` argument doesn't exist, create a new StoreCategory with this data.
   */
  create: Prisma.XOR<Prisma.StoreCategoryCreateInput, Prisma.StoreCategoryUncheckedCreateInput>
  /**
   * In case the StoreCategory was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.StoreCategoryUpdateInput, Prisma.StoreCategoryUncheckedUpdateInput>
}

/**
 * StoreCategory delete
 */
export type StoreCategoryDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
  /**
   * Filter which StoreCategory to delete.
   */
  where: Prisma.StoreCategoryWhereUniqueInput
}

/**
 * StoreCategory deleteMany
 */
export type StoreCategoryDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which StoreCategories to delete
   */
  where?: Prisma.StoreCategoryWhereInput
  /**
   * Limit how many StoreCategories to delete.
   */
  limit?: number
}

/**
 * StoreCategory.stores
 */
export type StoreCategory$storesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Store
   */
  select?: Prisma.StoreSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Store
   */
  omit?: Prisma.StoreOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreInclude<ExtArgs> | null
  where?: Prisma.StoreWhereInput
  orderBy?: Prisma.StoreOrderByWithRelationInput | Prisma.StoreOrderByWithRelationInput[]
  cursor?: Prisma.StoreWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.StoreScalarFieldEnum | Prisma.StoreScalarFieldEnum[]
}

/**
 * StoreCategory without action
 */
export type StoreCategoryDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StoreCategory
   */
  select?: Prisma.StoreCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the StoreCategory
   */
  omit?: Prisma.StoreCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StoreCategoryInclude<ExtArgs> | null
}
